Description: Upstream changes introduced in version 4.8.2-0ubuntu4
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 unity (4.8.2-0ubuntu4) oneiric; urgency=low
 .
   * Backport another trunk commit to fix an alt-tab segfault
 .
 The person named in the Author field signed this changelog entry.
Author: Sebastien Bacher <seb128@ubuntu.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- unity-4.8.2.orig/services/CMakeLists.txt
+++ unity-4.8.2/services/CMakeLists.txt
@@ -39,7 +39,7 @@ set(CFLAGS
     "-DGETTEXT_PACKAGE=\"unity\""
     "-DINDICATORDIR=\"${_indicatordir}\""
     "-DINDICATORICONDIR=\"${_iconsdir}\""
-    "-Werror -Wall"
+    "-Wall"
     )
 add_definitions(${CFLAGS})
 
--- unity-4.8.2.orig/plugins/networkarearegion/src/networkarearegion.cpp
+++ unity-4.8.2/plugins/networkarearegion/src/networkarearegion.cpp
@@ -75,8 +75,8 @@ UnityNETWorkareaRegionScreen::handleEven
   {
     case PropertyNotify:
 
-      if (event->xproperty.atom == (int) Atoms::wmStrut ||
-          event->xproperty.atom == (int) Atoms::wmStrutPartial)
+      if (event->xproperty.atom == (Atom) Atoms::wmStrut ||
+	  event->xproperty.atom == (Atom) Atoms::wmStrutPartial)
       {
         CompWindow* w = screen->findWindow(event->xproperty.window);
 
--- unity-4.8.2.orig/plugins/unityshell/unityshell.xml.in
+++ unity-4.8.2/plugins/unityshell/unityshell.xml.in
@@ -115,25 +115,38 @@
                       <_long>fixme</_long>
                       <default>&lt;Alt&gt;&lt;Shift&gt;Tab</default>
                 </option>
+		<option name="alt_tab_right" type="key">
+		    <_short>Go right in the switcher</_short>
+		    <_long>fixme</_long>
+		    <default>&lt;Alt&gt;Right</default>
+		    <passive_grab>false</passive_grab>
+		    <internal/>
+		</option>
+		<option name="alt_tab_left" type="key">
+		    <_short>Go left in the switcher</_short>
+		    <_long>fixme</_long>
+		    <default>&lt;Alt&gt;Left</default>
+		    <passive_grab>false</passive_grab>
+		    <internal/>
+		</option>
                 <option name="alt_tab_detail_start" type="key">
-                      <_short>Key to expose the windows in the switcher</_short>
-                      <_long>fixme</_long>
-                      <default>&lt;Alt&gt;Down</default>
-                </option>
-                <option name="alt_tab_detail_stop" type="key">
-                      <_short>Key to collapse windows in the switcher</_short>
-                      <_long>fixme</_long>
-                      <default>&lt;Alt&gt;Up</default>
+		    <_short>Key to expose the windows in the switcher</_short>
+		    <_long>fixme</_long>
+		    <default>&lt;Alt&gt;Down</default>
+		    <passive_grab>false</passive_grab>
+		    <internal/>
                 </option>
+		<option name="alt_tab_detail_stop" type="key">
+		    <_short>Key to collapse windows in the switcher</_short>
+		    <_long>fixme</_long>
+		    <default>&lt;Alt&gt;Up</default>
+		    <passive_grab>false</passive_grab>
+		    <internal/>
+		</option>
                 <option name="alt_tab_next_window" type="key">
-                      <_short>Key to flip through windows in the switcher</_short>
-                      <_long>fixme</_long>
-                      <default>&lt;Alt&gt;grave</default>
-                </option>
-                <option name="alt_tab_exit" type="key">
-                      <_short>Key to exit the switcher</_short>
-                      <_long>Causes the switcher window to go away without any changes to stacking state</_long>
-                      <default>&lt;Alt&gt;Escape</default>
+		    <_short>Key to flip through windows in the switcher</_short>
+		    <_long>fixme</_long>
+		    <default>&lt;Alt&gt;grave</default>
                 </option>
               </group>
               <group>
--- /dev/null
+++ unity-4.8.2/plugins/unityshell/src/DndData.h
@@ -0,0 +1,71 @@
+// -*- Mode: C++; indent-tabs-mode: nil; tab-width: 2 -*-
+/*
+* Copyright (C) 2011 Canonical Ltd
+*
+* This program is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 3 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*
+* Authored by: Andrea Azzarone <azzaronea@gmail.com>
+*/
+
+#ifndef DNDDATA_H
+#define DNDDATA_H
+
+#include <map>
+#include <set>
+#include <string>
+
+namespace unity {
+
+class DndData
+{
+public:
+  /**
+   * Fills the object given a list of uris.
+   **/
+  void Fill(char* uris);
+  
+  /**
+   * Resets the object. Call this function when no longer need data
+   **/
+  void Reset();
+  
+  /**
+   * Returns a std::set<std::string> with all the uris.
+   **/
+  std::set<std::string>& Uris() { return uris_; }
+  
+  /**
+   * Returns a std::set<std::string> with all the types.
+   **/
+  std::set<std::string>& Types() { return types_; }
+  
+  /**
+   * Returns a std::set<std::string> with all uris of a given type.
+   **/
+  std::set<std::string>& UrisByType(const std::string& type) { return types_to_uris_[type]; }
+  
+  /**
+   * Returns a std::set<std::string> with all types of a given uri.
+   **/
+  std::string& TypeByUri(const std::string& uris) { return uris_to_types_[uris]; }
+
+private:
+  std::set<std::string> uris_;
+  std::set<std::string> types_;
+  std::map<std::string, std::string> uris_to_types_;
+  std::map<std::string, std::set<std::string>> types_to_uris_;
+};
+
+} // namespace unity
+
+#endif // DNDDATA_H
--- unity-4.8.2.orig/plugins/unityshell/src/DashView.cpp
+++ unity-4.8.2/plugins/unityshell/src/DashView.cpp
@@ -67,6 +67,7 @@ void DashView::AboutToShow()
 {
   ubus_manager_.SendMessage(UBUS_BACKGROUND_REQUEST_COLOUR_EMIT);
   bg_effect_helper_.DirtyCache ();
+  search_bar_->text_entry()->SelectAll();
 }
 
 void DashView::SetupBackground()
@@ -165,6 +166,11 @@ nux::Geometry DashView::GetBestFitGeomet
   height += tile_height * 4.75;
   height += lens_bar_->GetGeometry().height;
 
+  if (for_geo.width > 800 && for_geo.height > 550)
+  {
+    width = MIN(width, for_geo.width-66);
+    height = MIN(height, for_geo.height-24);
+  }
   return nux::Geometry(0, 0, width, height);
 }
 
--- unity-4.8.2.orig/plugins/unityshell/src/LauncherIcon.h
+++ unity-4.8.2/plugins/unityshell/src/LauncherIcon.h
@@ -21,6 +21,9 @@
 #ifndef LAUNCHERICON_H
 #define LAUNCHERICON_H
 
+#include <set>
+#include <string>
+
 #include <Nux/Nux.h>
 #include <Nux/BaseWindow.h>
 #include <NuxCore/Math/MathInc.h>
@@ -43,7 +46,6 @@
 
 class Launcher;
 
-
 class LauncherIcon : public AbstractLauncherIcon, public unity::Introspectable, public nux::InitiallyUnownedObject
 {
   NUX_DECLARE_OBJECT_TYPE(LauncherIcon, nux::InitiallyUnownedObject);
@@ -150,14 +152,14 @@ public:
 
   void RemoveEntryRemote(LauncherEntryRemote* remote);
 
-  nux::DndAction QueryAcceptDrop(std::list<char*> paths)
+  nux::DndAction QueryAcceptDrop(unity::DndData& dnd_data)
   {
-    return OnQueryAcceptDrop(paths);
+    return OnQueryAcceptDrop(dnd_data);
   }
 
-  void AcceptDrop(std::list<char*> paths)
+  void AcceptDrop(unity::DndData& dnd_data)
   {
-    return OnAcceptDrop(paths);
+    return OnAcceptDrop(dnd_data);
   }
 
   void SendDndEnter()
@@ -221,12 +223,12 @@ protected:
     return 0;
   }
 
-  virtual nux::DndAction OnQueryAcceptDrop(std::list<char*> files)
+  virtual nux::DndAction OnQueryAcceptDrop(unity::DndData& dnd_data)
   {
     return nux::DNDACTION_NONE;
   }
 
-  virtual void OnAcceptDrop(std::list<char*> files) {}
+  virtual void OnAcceptDrop(unity::DndData& dnd_data) {}
 
   virtual void OnDndEnter() {}
 
@@ -327,7 +329,7 @@ private:
 
   std::list<LauncherEntryRemote*> _entry_list;
   std::map<std::string, std::vector<nux::Vector4> > transform_map;
-
+  
 };
 
 #endif // LAUNCHERICON_H
--- unity-4.8.2.orig/plugins/unityshell/src/SwitcherController.cpp
+++ unity-4.8.2/plugins/unityshell/src/SwitcherController.cpp
@@ -126,24 +126,26 @@ void SwitcherController::OnModelSelectio
 
 void SwitcherController::ConstructView()
 {
-  nux::HLayout* layout;
-
-  layout = new nux::HLayout();
-
   view_ = new SwitcherView();
   view_->SetModel(model_);
   view_->background_color = bg_color_;
 
-  layout->AddView(view_, 1);
-  layout->SetVerticalExternalMargin(0);
-  layout->SetHorizontalExternalMargin(0);
-
-  view_window_ = new nux::BaseWindow("Switcher");
-  view_window_->SinkReference();
-  view_window_->SetLayout(layout);
-  view_window_->SetBackgroundColor(nux::Color(0x00000000));
-  view_window_->SetGeometry(workarea_);
+  if (!view_window_)
+  {
+    main_layout_ = new nux::HLayout();
+    
+    main_layout_->SetVerticalExternalMargin(0);
+    main_layout_->SetHorizontalExternalMargin(0);
+
+    view_window_ = new nux::BaseWindow("Switcher");
+    view_window_->SinkReference();
+    view_window_->SetLayout(main_layout_);
+    view_window_->SetBackgroundColor(nux::Color(0x00000000));
+  }
+  
+  main_layout_->AddView(view_, 1);
 
+  view_window_->SetGeometry(workarea_);
   view_window_->ShowWindow(true);
 }
 
@@ -183,12 +185,11 @@ void SwitcherController::Hide(bool accep
   model_.reset();
   visible_ = false;
 
+  if (view_)
+    main_layout_->RemoveChildObject(view_);
+
   if (view_window_)
-  {
     view_window_->ShowWindow(false);
-    view_window_->UnReference();
-    view_window_ = 0;
-  }
 
   if (show_timer_)
     g_source_remove(show_timer_);
--- unity-4.8.2.orig/plugins/unityshell/src/SwitcherController.h
+++ unity-4.8.2/plugins/unityshell/src/SwitcherController.h
@@ -102,6 +102,7 @@ private:
   nux::Geometry workarea_;
 
   nux::BaseWindow* view_window_;
+  nux::HLayout* main_layout_;
 
   bool visible_;
   guint show_timer_;
--- unity-4.8.2.orig/plugins/unityshell/src/SimpleLauncherIcon.cpp
+++ unity-4.8.2/plugins/unityshell/src/SimpleLauncherIcon.cpp
@@ -114,9 +114,8 @@ void SimpleLauncherIcon::SetIconName(con
 void SimpleLauncherIcon::ReloadIcon()
 {
   for (auto element : texture_map)
-  {
-    element.second->UnReference();
-  }
+    if (element.second)
+      element.second->UnReference();
 
   texture_map.clear ();
   needs_redraw.emit(this);
--- unity-4.8.2.orig/plugins/unityshell/src/MockLauncherIcon.h
+++ unity-4.8.2/plugins/unityshell/src/MockLauncherIcon.h
@@ -179,12 +179,12 @@ public:
     return std::list<DbusmenuMenuitem*> ();
   }
 
-  nux::DndAction QueryAcceptDrop(std::list<char*> paths)
+  nux::DndAction QueryAcceptDrop(unity::DndData& dnd_data)
   {
     return nux::DNDACTION_NONE;
   }
 
-  void AcceptDrop(std::list<char*> paths) {}
+  void AcceptDrop(unity::DndData& dnd_data) {}
 
   void SendDndEnter() {}
 
--- unity-4.8.2.orig/plugins/unityshell/src/PanelStyle.cpp
+++ unity-4.8.2/plugins/unityshell/src/PanelStyle.cpp
@@ -180,7 +180,7 @@ PanelStyle::GetWindowButton(WindowButton
     if (!var)
       var = "/usr";
 
-    glib::String filename(g_build_filename(var, _theme_name, subpath.str().c_str(), NULL));
+    glib::String filename(g_build_filename(var, "share", "themes", _theme_name, subpath.str().c_str(), NULL));
 
     if (g_file_test(filename.Value(), G_FILE_TEST_EXISTS))
     {
--- /dev/null
+++ unity-4.8.2/plugins/unityshell/src/DNDCollectionWindow.h
@@ -0,0 +1,55 @@
+// -*- Mode: C++; indent-tabs-mode: nil; tab-width: 2 -*-
+/*
+* Copyright (C) 2011 Canonical Ltd
+*
+* This program is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 3 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*
+* Authored by: Andrea Azzarone <azzaronea@gmail.com>
+*/
+
+#ifndef DNDCOLLECTIONWINDOW_H
+#define DNDCOLLECTIONWINDOW_H
+
+#include <list>
+
+#include <core/screen.h>
+#include <Nux/Nux.h>
+#include <Nux/BaseWindow.h>
+#include <sigc++/sigc++.h>
+
+namespace unity {
+  
+class DNDCollectionWindow : public nux::BaseWindow
+{
+NUX_DECLARE_OBJECT_TYPE(DNDCollectionWindow, nux::BaseWindow);
+
+// Methods
+public:
+  DNDCollectionWindow(CompScreen* screen);
+  ~DNDCollectionWindow();
+  
+private:
+  void ProcessDndMove(int x, int y, std::list<char*> mimes);
+
+// Members
+public:
+  sigc::signal<void, const std::list<char*>&> collected;
+  
+private:
+  std::list<char*> mimes_;
+  
+};
+  
+} // namespace unity
+
+#endif // DNDCOLLECTIONWINDOW_H
--- unity-4.8.2.orig/plugins/unityshell/src/TrashLauncherIcon.cpp
+++ unity-4.8.2/plugins/unityshell/src/TrashLauncherIcon.cpp
@@ -18,16 +18,18 @@
  */
 
 #include "TrashLauncherIcon.h"
-#include "Launcher.h"
-#include "Nux/WindowCompositor.h"
 
-#include "QuicklistManager.h"
-#include "QuicklistMenuItemLabel.h"
+#include <Nux/WindowCompositor.h>
 
 #include <gio/gio.h>
 #include <glib/gi18n-lib.h>
 #include <gconf/gconf-client.h>
 
+#include "Launcher.h"
+#include "QuicklistManager.h"
+#include "QuicklistMenuItemLabel.h"
+
+
 #define ASK_CONFIRMATION_KEY "/apps/nautilus/preferences/confirm_trash"
 
 TrashLauncherIcon::TrashLauncherIcon(Launcher* IconManager)
@@ -277,19 +279,17 @@ TrashLauncherIcon::OnTrashChanged(GFileM
 }
 
 nux::DndAction
-TrashLauncherIcon::OnQueryAcceptDrop(std::list<char*> uris)
+TrashLauncherIcon::OnQueryAcceptDrop(unity::DndData& dnd_data)
 {
   return nux::DNDACTION_MOVE;
 }
 
 void
-TrashLauncherIcon::OnAcceptDrop(std::list<char*> uris)
+TrashLauncherIcon::OnAcceptDrop(unity::DndData& dnd_data)
 {
-  std::list<char*>::iterator it;
-
-  for (it = uris.begin(); it != uris.end(); it++)
+  for (auto it : dnd_data.Uris())
   {
-    GFile* file = g_file_new_for_uri(*it);
+    GFile* file = g_file_new_for_uri(it.c_str());
     g_file_trash(file, NULL, NULL);
     g_object_unref(file);
   }
--- unity-4.8.2.orig/plugins/unityshell/src/unityshell.h
+++ unity-4.8.2/plugins/unityshell/src/unityshell.h
@@ -146,18 +146,18 @@ public:
   bool setKeyboardFocusKeyInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options);
   bool launcherRevealEdgeInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options);
 
+  bool altTabInitiateCommon(CompAction* action,
+                            CompAction::State state,
+                            CompOption::Vector& options);
+  bool altTabTerminateCommon(CompAction* action,
+                             CompAction::State state,
+                             CompOption::Vector& options);
+
   bool altTabForwardInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options);
-  bool altTabForwardTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options);
   bool altTabPrevInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options);
-  bool altTabPrevTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options);
   bool altTabDetailStartInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options);
-  bool altTabDetailStartTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options);
   bool altTabDetailStopInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options);
-  bool altTabDetailStopTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options);
   bool altTabNextWindowInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options);
-  bool altTabNextWindowTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options);
-  bool altTabExitInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options);
-  bool altTabExitTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options);
 
   /* handle option changes and change settings inside of the
    * panel and dock views */
@@ -257,6 +257,7 @@ private:
 
   UBusManager ubus_manager_;
   bool dash_is_open_;
+  CompScreen::GrabHandle grab_index_;
 
 	friend class UnityWindow;
 };
--- unity-4.8.2.orig/plugins/unityshell/src/LauncherIcon.cpp
+++ unity-4.8.2/plugins/unityshell/src/LauncherIcon.cpp
@@ -804,10 +804,10 @@ LauncherIcon::SetQuirk(LauncherIcon::Qui
 {
   if (_quirks[quirk] == value)
     return;
-    
+      
   if (quirk == QUIRK_PULSE_ONCE)
     _launcher->HideMachine()->SetQuirk(LauncherHideMachine::LAUNCHER_PULSE, value);
-
+  
   _quirks[quirk] = value;
   if (quirk == QUIRK_VISIBLE)
     Launcher::SetTimeStruct(&(_quirk_times[quirk]), &(_quirk_times[quirk]), ANIM_DURATION_SHORT);
--- unity-4.8.2.orig/plugins/unityshell/src/AbstractLauncherIcon.h
+++ unity-4.8.2/plugins/unityshell/src/AbstractLauncherIcon.h
@@ -31,6 +31,8 @@
 
 #include <libdbusmenu-glib/menuitem.h>
 
+#include "DndData.h"
+
 class ActionArg
 {
 public:
@@ -161,9 +163,9 @@ public:
 
   virtual std::list<DbusmenuMenuitem*> Menus() = 0;
 
-  virtual nux::DndAction QueryAcceptDrop(std::list<char*> paths) = 0;
+  virtual nux::DndAction QueryAcceptDrop(unity::DndData& dnd_data) = 0;
 
-  virtual void AcceptDrop(std::list<char*> paths) = 0;
+  virtual void AcceptDrop(unity::DndData& dnd_data) = 0;
 
   virtual void SendDndEnter() = 0;
 
--- /dev/null
+++ unity-4.8.2/plugins/unityshell/src/DNDCollectionWindow.cpp
@@ -0,0 +1,63 @@
+// -*- Mode: C++; indent-tabs-mode: nil; tab-width: 2 -*-
+/*
+* Copyright (C) 2011 Canonical Ltd
+*
+* This program is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 3 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*
+* Authored by: Andrea Azzarone <azzaronea@gmail.com>
+*/
+
+#include "DNDCollectionWindow.h"
+
+namespace unity {
+  
+NUX_IMPLEMENT_OBJECT_TYPE(DNDCollectionWindow);
+
+DNDCollectionWindow::DNDCollectionWindow(CompScreen* screen)
+  : nux::BaseWindow("")
+{
+  SetBackgroundColor(nux::Color(0x00000000));
+  SetBaseSize(screen->width(), screen->height());
+  SetBaseXY(0, 0);
+  
+  ShowWindow(true);
+  PushToBack();
+  // Hack
+  EnableInputWindow(true, "DNDCollectionWindow");
+  EnableInputWindow(false, "DNDCollectionWindow");
+  SetDndEnabled(false, true);
+}
+
+DNDCollectionWindow::~DNDCollectionWindow()
+{
+  for (auto it : mimes_)
+    g_free(it);
+}
+
+void DNDCollectionWindow::ProcessDndMove(int x, int y, std::list<char*> mimes)
+{  
+  // Hide the window as soon as possible
+  EnableInputWindow(false, "DNDCollectionWindow");
+
+  for (auto it : mimes_)
+    g_free(it);
+  mimes_.clear();
+  
+  // Duplicate the list
+  for (auto it : mimes)
+    mimes_.push_back(g_strdup(it));
+  
+  collected.emit(mimes_);
+}
+  
+} // namespace unity
--- unity-4.8.2.orig/plugins/unityshell/src/Launcher.cpp
+++ unity-4.8.2/plugins/unityshell/src/Launcher.cpp
@@ -48,12 +48,11 @@
 #include "ubus-server.h"
 #include "UBusMessages.h"
 
+#include <UnityCore/GLibWrapper.h>
 #include <UnityCore/Variant.h>
 
 using namespace unity::ui;
 
-using namespace unity::ui;
-
 namespace
 {
 
@@ -136,13 +135,15 @@ GDBusInterfaceVTable Launcher::interface
 Launcher::Launcher(nux::BaseWindow* parent,
                    CompScreen*      screen,
                    NUX_FILE_LINE_DECL)
-  :   View(NUX_FILE_LINE_PARAM)
-  ,   m_ContentOffsetY(0)
-  ,   m_BackgroundLayer(0)
-  ,   _model(0)
-  ,   _background_color (nux::color::DimGray)
-  ,   _dash_is_open (false)
+  : View(NUX_FILE_LINE_PARAM)
+  , m_ContentOffsetY(0)
+  , m_BackgroundLayer(0)
+  , _model(0)
+  , _collection_window(NULL)
+  , _background_color(nux::color::DimGray)
+  , _dash_is_open(false)
 {
+  
   _parent = parent;
   _screen = screen;
   _active_quicklist = 0;
@@ -263,6 +264,11 @@ Launcher::Launcher(nux::BaseWindow* pare
   _bfb_width = 1;
   _bfb_height = 1;
 
+  _data_checked = false;
+  _collection_window = new unity::DNDCollectionWindow(_screen);
+  _collection_window->SinkReference();
+  _on_data_collected_connection = _collection_window->collected.connect(sigc::mem_fun(this, &Launcher::OnDNDDataCollected));
+
   // 0 out timers to avoid wonky startups
   int i;
   for (i = 0; i < TIME_LAST; ++i)
@@ -271,6 +277,7 @@ Launcher::Launcher(nux::BaseWindow* pare
     _times[i].tv_nsec = 0;
   }
 
+  _dnd_hovered_icon = NULL;
   _drag_window = NULL;
   _offscreen_drag_texture = nux::GetGraphicsDisplay()->GetGpuDevice()->CreateSystemCapableDeviceTexture(2, 2, 1, nux::BITFMT_R8G8B8A8);
 
@@ -350,6 +357,9 @@ Launcher::~Launcher()
 
   if (_launcher_animation_timeout > 0)
     g_source_remove(_launcher_animation_timeout);
+    
+  if (_on_data_collected_connection.connected())
+      _on_data_collected_connection.disconnect();
 
   UBusServer* ubus = ubus_server_get_default();
   for (unsigned int i = 0; i < G_N_ELEMENTS(_ubus_handles); ++i)
@@ -359,6 +369,9 @@ Launcher::~Launcher()
   }
 
   g_idle_remove_by_data(this);
+  
+  if (_collection_window)
+    _collection_window->UnReference();
 
   delete _hover_machine;
   delete _hide_machine;
@@ -656,7 +669,7 @@ bool Launcher::IconNeedsAnimation(Launch
   time = icon->GetQuirkTime(LauncherIcon::QUIRK_PROGRESS);
   if (TimeDelta(&current, &time) < ANIM_DURATION)
     return true;
-
+    
   time = icon->GetQuirkTime(LauncherIcon::QUIRK_DROP_DIM);
   if (TimeDelta(&current, &time) < ANIM_DURATION)
     return true;
@@ -1091,7 +1104,7 @@ void Launcher::FillRenderArg(LauncherIco
     arg.alpha *= size_modifier;
     center.z = 300.0f * (1.0f - size_modifier);
   }
-
+  
   float drop_dim_value = 0.2f + 0.8f * IconDropDimValue(icon, current);
 
   if (drop_dim_value < 1.0f)
@@ -1513,7 +1526,7 @@ void Launcher::SetHidden(bool hidden)
   _parent->EnableInputWindow(!hidden, "launcher", false, false);
 
   if (!hidden && GetActionState() == ACTION_DRAG_EXTERNAL)
-    ProcessDndLeave();
+    DndLeave();
 
   EnsureAnimation();
 
@@ -1614,10 +1627,19 @@ Launcher::OnUpdateDragManagerTimeout(gpo
 
   if (drag_owner && (mask & (Button1Mask | Button2Mask | Button3Mask)))
   {
-    self->_hide_machine->SetQuirk(LauncherHideMachine::EXTERNAL_DND_ACTIVE, true);
+    if (self->_data_checked == false)
+    {
+      self->_data_checked = true;
+      self->_collection_window->EnableInputWindow(true, "DNDCollectionWindow");
+    } 
+    
     return true;
   }
+  
+  self->_data_checked = false;
+  self->_collection_window->EnableInputWindow(false, "DNDCollectionWindow");
 
+  self->DndLeave();
   self->_hide_machine->SetQuirk(LauncherHideMachine::EXTERNAL_DND_ACTIVE, false);
   self->_hide_machine->SetQuirk(LauncherHideMachine::DND_PUSHED_OFF, false);
 
@@ -1681,11 +1703,6 @@ Launcher::OnPluginStateChanged()
   
   if (_hidemode == LAUNCHER_HIDE_NEVER)
     return;
-    
-  if (PluginAdapter::Default ()->IsScaleActive ())                   
-    _parent->InputWindowEnableStruts (true);
-  else
-    _parent->InputWindowEnableStruts (false);
 }
 
 Launcher::LauncherHideMode Launcher::GetHideMode()
@@ -2803,10 +2820,51 @@ Launcher::RestoreSystemRenderTarget()
   nux::GetWindowCompositor().RestoreRenderingSurface();
 }
 
+void Launcher::OnDNDDataCollected(const std::list<char*>& mimes)
+{
+  _dnd_data.Reset();
+
+  unity::glib::String uri_list_const(g_strdup("text/uri-list"));
+
+  for (auto it : mimes)
+  {    
+    if (!g_str_equal(it, uri_list_const.Value()))
+      continue;
+
+    _dnd_data.Fill(nux::GetWindow().GetDndData(uri_list_const.Value()));
+    break;
+  }
+  
+  if (!_dnd_data.Uris().size())
+    return;
+    
+  _hide_machine->SetQuirk(LauncherHideMachine::EXTERNAL_DND_ACTIVE, true);
+  
+  for (auto it : _dnd_data.Uris())
+  {
+    if (g_str_has_suffix(it.c_str(), ".desktop"))
+    {
+      _steal_drag = true;
+      break;
+    }
+  }
+  
+  if (!_steal_drag)
+  {
+    for (auto it : *_model)
+    {
+      if (it->QueryAcceptDrop(_dnd_data) != nux::DNDACTION_NONE)
+        it->SetQuirk(LauncherIcon::QUIRK_DROP_PRELIGHT, true);
+      else
+        it->SetQuirk(LauncherIcon::QUIRK_DROP_DIM, true);
+    }
+  }  
+}
+
 void
 Launcher::ProcessDndEnter()
 {
-  _drag_data.clear();
+  _dnd_data.Reset();
   _drag_action = nux::DNDACTION_NONE;
   _steal_drag = false;
   _data_checked = false;
@@ -2815,35 +2873,32 @@ Launcher::ProcessDndEnter()
 }
 
 void
-Launcher::ProcessDndLeave()
+Launcher::DndLeave()
 {
-  SetStateMouseOverLauncher(false);
-  _drag_edge_touching = false;
-
-  SetActionState(ACTION_NONE);
+  
+  _dnd_data.Reset();
 
-  if (!_drag_data.empty())
+  for (auto it : *_model)
   {
-    std::list<char*>::iterator it;
-    for (it = _drag_data.begin(); it != _drag_data.end(); it++)
-    {
-      g_free(*it);
-    }
+    it->SetQuirk(LauncherIcon::QUIRK_DROP_PRELIGHT, false);
+    it->SetQuirk(LauncherIcon::QUIRK_DROP_DIM, false);
   }
-  _drag_data.clear();
+  
+  ProcessDndLeave();
+}
 
-  LauncherModel::iterator it;
-  for (it = _model->begin(); it != _model->end(); it++)
-  {
-    (*it)->SetQuirk(LauncherIcon::QUIRK_DROP_PRELIGHT, false);
-    (*it)->SetQuirk(LauncherIcon::QUIRK_DROP_DIM, false);
-  }
+void
+Launcher::ProcessDndLeave()
+{
+  SetStateMouseOverLauncher(false);
+  _drag_edge_touching = false;
 
+  SetActionState(ACTION_NONE);
+  
   if (_steal_drag && _dnd_hovered_icon)
   {
     _dnd_hovered_icon->SetQuirk(LauncherIcon::QUIRK_VISIBLE, false);
     _dnd_hovered_icon->remove.emit(_dnd_hovered_icon);
-
   }
 
   if (!_steal_drag && _dnd_hovered_icon)
@@ -2854,58 +2909,33 @@ Launcher::ProcessDndLeave()
 
   _steal_drag = false;
   _dnd_hovered_icon = 0;
-
-}
-
-std::list<char*>
-Launcher::StringToUriList(char* input)
-{
-  std::list<char*> result;
-
-  if (!input)
-    return result;
-
-  char** imtrappedinastringfactory = g_strsplit(input, "\r\n", -1);
-  int i = 0;
-  while (imtrappedinastringfactory[i]) // get kinda bored
-  {
-    // empty string check
-    if (imtrappedinastringfactory[i][0])
-      result.push_back(g_strdup(imtrappedinastringfactory[i]));
-    ++i;
-  }
-
-  g_strfreev(imtrappedinastringfactory);
-
-  return result;
 }
 
 void
 Launcher::ProcessDndMove(int x, int y, std::list<char*> mimes)
 {
-  std::list<char*>::iterator it;
   nux::Area* parent = GetToplevel();
-  char* uri_list_const = g_strdup("text/uri-list");
+  unity::glib::String uri_list_const(g_strdup("text/uri-list"));
 
   if (!_data_checked)
   {
     _data_checked = true;
-    _drag_data.clear();
+    _dnd_data.Reset();
 
     // get the data
-    for (it = mimes.begin(); it != mimes.end(); it++)
-    {
-      if (!g_str_equal(*it, uri_list_const))
+    for (auto it : mimes)
+    {    
+      if (!g_str_equal(it, uri_list_const.Value()))
         continue;
 
-      _drag_data = StringToUriList(nux::GetWindow().GetDndData(uri_list_const));
+      _dnd_data.Fill(nux::GetWindow().GetDndData(uri_list_const.Value()));
       break;
     }
-
+  
     // see if the launcher wants this one
-    for (it = _drag_data.begin(); it != _drag_data.end(); it++)
+    for (auto it : _dnd_data.Uris())
     {
-      if (g_str_has_suffix(*it, ".desktop"))
+      if (g_str_has_suffix(it.c_str(), ".desktop"))
       {
         _steal_drag = true;
         break;
@@ -2916,19 +2946,18 @@ Launcher::ProcessDndMove(int x, int y, s
     SetActionState(ACTION_DRAG_EXTERNAL);
     SetStateMouseOverLauncher(true);
 
-    LauncherModel::iterator it;
-    for (it = _model->begin(); it != _model->end() && !_steal_drag; it++)
+    if (!_steal_drag)
     {
-      if ((*it)->QueryAcceptDrop(_drag_data) != nux::DNDACTION_NONE && !_steal_drag)
-        (*it)->SetQuirk(LauncherIcon::QUIRK_DROP_PRELIGHT, true);
-      else
-        (*it)->SetQuirk(LauncherIcon::QUIRK_DROP_DIM, true);
+      for (auto it : *_model)
+      {
+        if (it->QueryAcceptDrop(_dnd_data) != nux::DNDACTION_NONE)
+          it->SetQuirk(LauncherIcon::QUIRK_DROP_PRELIGHT, true);
+        else
+          it->SetQuirk(LauncherIcon::QUIRK_DROP_DIM, true);
+      }
     }
-
   }
 
-  g_free(uri_list_const);
-
   SetMousePosition(x - parent->GetGeometry().x, y - parent->GetGeometry().y);
 
   if (_mouse_position.x == 0 && _mouse_position.y <= (_parent->GetGeometry().height - _icon_size - 2 * _space_between_icons) && !_drag_edge_touching)
@@ -2991,7 +3020,7 @@ Launcher::ProcessDndMove(int x, int y, s
       if (hovered_icon)
       {
         hovered_icon->SendDndEnter();
-        _drag_action = hovered_icon->QueryAcceptDrop(_drag_data);
+        _drag_action = hovered_icon->QueryAcceptDrop(_dnd_data);
       }
       else
       {
@@ -3020,23 +3049,21 @@ Launcher::ProcessDndDrop(int x, int y)
   if (_steal_drag)
   {
     char* path = 0;
-    std::list<char*>::iterator it;
 
-    for (it = _drag_data.begin(); it != _drag_data.end(); it++)
+    for (auto it : _dnd_data.Uris())
     {
-      if (g_str_has_suffix(*it, ".desktop"))
+      if (g_str_has_suffix(it.c_str(), ".desktop"))
       {
-        if (g_str_has_prefix(*it, "application://"))
+        if (g_str_has_prefix(it.c_str(), "application://"))
         {
-          const char* tmp = *it + strlen("application://");
-          char* tmp2 = g_strdup_printf("file:///usr/share/applications/%s", tmp);
-          path = g_filename_from_uri(tmp2, NULL, NULL);
-          g_free(tmp2);
+          const char* tmp = it.c_str() + strlen("application://");
+          unity::glib::String tmp2(g_strdup_printf("file:///usr/share/applications/%s", tmp));
+          path = g_filename_from_uri(tmp2.Value(), NULL, NULL);
           break;
         }
-        else if (g_str_has_prefix(*it, "file://"))
+        else if (g_str_has_prefix(it.c_str(), "file://"))
         {
-          path = g_filename_from_uri(*it, NULL, NULL);
+          path = g_filename_from_uri(it.c_str(), NULL, NULL);
           break;
         }
       }
@@ -3050,7 +3077,7 @@ Launcher::ProcessDndDrop(int x, int y)
   }
   else if (_dnd_hovered_icon && _drag_action != nux::DNDACTION_NONE)
   {
-    _dnd_hovered_icon->AcceptDrop(_drag_data);
+    _dnd_hovered_icon->AcceptDrop(_dnd_data);
   }
 
   if (_drag_action != nux::DNDACTION_NONE)
@@ -3059,10 +3086,9 @@ Launcher::ProcessDndDrop(int x, int y)
     SendDndFinished(false, _drag_action);
 
   // reset our shiz
-  ProcessDndLeave();
+  DndLeave();
 }
 
-
 /*
  * Returns the current selected icon if it is in keynavmode
  * It will return NULL if it is not on keynavmode
--- unity-4.8.2.orig/plugins/unityshell/src/IMTextEntry.cpp
+++ unity-4.8.2/plugins/unityshell/src/IMTextEntry.cpp
@@ -199,6 +199,7 @@ void IMTextEntry::OnFocusChanged(nux::Ar
 void IMTextEntry::OnCommit(GtkIMContext* context, char* str)
 {
   LOG_DEBUG(logger) << "Commit: " << str;
+  DeleteSelection();
   if (str)
   {
     std::string new_text = GetText() + str;
--- unity-4.8.2.orig/plugins/unityshell/src/BamfLauncherIcon.h
+++ unity-4.8.2/plugins/unityshell/src/BamfLauncherIcon.h
@@ -63,14 +63,14 @@ protected:
 
   const gchar* GetRemoteUri();
 
-  nux::DndAction OnQueryAcceptDrop(std::list<char*> uris);
-  void OnAcceptDrop(std::list<char*> uris);
+  nux::DndAction OnQueryAcceptDrop(unity::DndData& dnd_data);
+  void OnAcceptDrop(unity::DndData& dnd_data);
   void OnDndEnter();
   void OnDndLeave();
 
   void OpenInstanceLauncherIcon(ActionArg arg);
 
-  std::list<char*> ValidateUrisForLaunch(std::list<char*> uris);
+  std::set<std::string> ValidateUrisForLaunch(unity::DndData& dnd_data);
 
   const char* BamfName();
 
@@ -89,15 +89,18 @@ private:
   gchar* _cached_desktop_file;
   gchar* _cached_name;
 
-
   GFileMonitor* _desktop_file_monitor;
   gulong _on_desktop_file_changed_handler_id;
+  
+  std::set<std::string> _supported_types;
+  bool _supported_types_filled;
+  guint _fill_supported_types_id;
 
   void EnsureWindowState();
 
   void UpdateMenus();
 
-  void OpenInstanceWithUris(std::list<char*> uris);
+  void OpenInstanceWithUris(std::set<std::string> uris);
   void Focus();
   bool Spread(int state, bool force);
 
@@ -105,6 +108,8 @@ private:
 
   void OnWindowMinimized(guint32 xid);
   bool OwnsWindow(Window w);
+  
+  const std::set<std::string>& GetSupportedTypes();
 
   static void OnClosed(BamfView* view, gpointer data);
   static void OnUserVisibleChanged(BamfView* view, gboolean visible, gpointer data);
@@ -125,6 +130,7 @@ private:
                                    gpointer             data);
 
   static gboolean OnDndHoveredTimeout(gpointer data);
+  static gboolean FillSupportedTypes(gpointer data);
 };
 
 #endif // BAMFLAUNCHERICON_H
--- unity-4.8.2.orig/plugins/unityshell/src/BackgroundEffectHelper.cpp
+++ unity-4.8.2/plugins/unityshell/src/BackgroundEffectHelper.cpp
@@ -38,6 +38,7 @@ BackgroundEffectHelper::BackgroundEffect
 
 BackgroundEffectHelper::~BackgroundEffectHelper()
 {
+  noise_texture_->UnReference();
   Unregister(this);
 }
 
--- /dev/null
+++ unity-4.8.2/plugins/unityshell/src/DndData.cpp
@@ -0,0 +1,63 @@
+// -*- Mode: C++; indent-tabs-mode: nil; tab-width: 2 -*-
+/*
+* Copyright (C) 2011 Canonical Ltd
+*
+* This program is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 3 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*
+* Authored by: Andrea Azzarone <azzaronea@gmail.com>
+*/
+
+#include "DndData.h"
+
+#include <cstring>
+#include <vector>
+
+#include <gio/gio.h>
+
+#include <UnityCore/GLibWrapper.h>
+
+namespace unity {
+  
+void DndData::Fill(char* uris)
+{ 
+  Reset();
+  
+  char* pch = strtok (uris, "\r\n");
+  while (pch != NULL)
+  {
+    glib::Object<GFile> file(g_file_new_for_uri(pch));
+    glib::Object<GFileInfo> info(g_file_query_info(file, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, G_FILE_QUERY_INFO_NONE, NULL, NULL));
+    const char* content_type = g_file_info_get_content_type(info);
+    
+    uris_.insert(pch);
+    
+    if (content_type != NULL)
+    {
+      types_.insert(content_type);
+      uris_to_types_[pch] = content_type;
+      types_to_uris_[content_type].insert(pch);
+    }
+       
+    pch = strtok (NULL, "\r\n");
+  }
+}
+
+void DndData::Reset()
+{
+  uris_.clear();
+  types_.clear();
+  uris_to_types_.clear();
+  types_to_uris_.clear();
+}
+
+} // namespace unity
--- unity-4.8.2.orig/plugins/unityshell/src/BamfLauncherIcon.cpp
+++ unity-4.8.2/plugins/unityshell/src/BamfLauncherIcon.cpp
@@ -21,12 +21,11 @@
 #include "Nux/BaseWindow.h"
 
 #include "BamfLauncherIcon.h"
+#include "FavoriteStore.h"
 #include "Launcher.h"
 #include "PluginAdapter.h"
-#include "FavoriteStore.h"
-
-#include "ubus-server.h"
 #include "UBusMessages.h"
+#include "ubus-server.h"
 
 #include <glib/gi18n-lib.h>
 #include <gio/gdesktopappinfo.h>
@@ -34,6 +33,8 @@
 #include <core/core.h>
 #include <core/atoms.h>
 
+#include <UnityCore/GLibWrapper.h>
+
 using unity::FavoriteStore;
 
 struct _ShortcutData
@@ -133,7 +134,9 @@ void BamfLauncherIcon::ActivateLauncherI
 }
 
 BamfLauncherIcon::BamfLauncherIcon(Launcher* IconManager, BamfApplication* app, CompScreen* screen)
-  :   SimpleLauncherIcon(IconManager)
+  : SimpleLauncherIcon(IconManager)
+  , _supported_types_filled(false)
+  , _fill_supported_types_id(0)
 {
   _cached_desktop_file = NULL;
   _cached_name = NULL;
@@ -188,8 +191,11 @@ BamfLauncherIcon::BamfLauncherIcon(Launc
   PluginAdapter::Default()->window_minimized.connect(sigc::mem_fun(this, &BamfLauncherIcon::OnWindowMinimized));
   IconManager->hidden_changed.connect(sigc::mem_fun(this, &BamfLauncherIcon::OnLauncherHiddenChanged));
 
-  /* hack */
+  // hack
   SetProgress(0.0f);
+  
+  // Calls when there are no higher priority events pending to the default main loop.
+  _fill_supported_types_id = g_idle_add((GSourceFunc)FillSupportedTypes, this);
 
 }
 
@@ -213,6 +219,9 @@ BamfLauncherIcon::~BamfLauncherIcon()
   if (_on_desktop_file_changed_handler_id != 0)
     g_signal_handler_disconnect((gpointer) _desktop_file_monitor,
                                 _on_desktop_file_changed_handler_id);
+                                
+  if (_fill_supported_types_id != 0)
+    g_source_remove(_fill_supported_types_id);
 
   g_signal_handlers_disconnect_by_func(m_App, (void*) &BamfLauncherIcon::OnChildRemoved,       this);
   g_signal_handlers_disconnect_by_func(m_App, (void*) &BamfLauncherIcon::OnChildAdded,         this);
@@ -352,11 +361,10 @@ bool BamfLauncherIcon::OwnsWindow(Window
   return owns;
 }
 
-void BamfLauncherIcon::OpenInstanceWithUris(std::list<char*> uris)
+void BamfLauncherIcon::OpenInstanceWithUris(std::set<std::string> uris)
 {
   GDesktopAppInfo* appInfo;
   GError* error = NULL;
-  std::list<char*>::iterator it;
 
   appInfo = g_desktop_app_info_new_from_filename(bamf_application_get_desktop_file(BAMF_APPLICATION(m_App)));
 
@@ -364,18 +372,19 @@ void BamfLauncherIcon::OpenInstanceWithU
   {
     GList* list = NULL;
 
-    for (it = uris.begin(); it != uris.end(); it++)
-      list = g_list_prepend(list, *it);
+    for (auto  it : uris)
+      list = g_list_prepend(list, g_strdup(it.c_str()));
 
     g_app_info_launch_uris(G_APP_INFO(appInfo), list, NULL, &error);
-    g_list_free(list);
+    g_list_free_full(list, g_free);
   }
   else if (g_app_info_supports_files(G_APP_INFO(appInfo)))
   {
     GList* list = NULL, *l;
-    for (it = uris.begin(); it != uris.end(); it++)
+    
+    for (auto it : uris)
     {
-      GFile* file = g_file_new_for_uri(*it);
+      GFile* file = g_file_new_for_uri(it.c_str());
       list = g_list_prepend(list, file);
     }
     g_app_info_launch(G_APP_INFO(appInfo), list, NULL, &error);
@@ -403,7 +412,7 @@ void BamfLauncherIcon::OpenInstanceWithU
 
 void BamfLauncherIcon::OpenInstanceLauncherIcon(ActionArg arg)
 {
-  std::list<char*> empty;
+  std::set<std::string> empty;
   OpenInstanceWithUris(empty);
   ubus_server_send_message(ubus_server_get_default(), UBUS_LAUNCHER_ACTION_DONE, NULL);
 }
@@ -1038,62 +1047,21 @@ const gchar* BamfLauncherIcon::GetRemote
   return _remote_uri;
 }
 
-std::list<char*> BamfLauncherIcon::ValidateUrisForLaunch(std::list<char*> uris)
+std::set<std::string> BamfLauncherIcon::ValidateUrisForLaunch(unity::DndData& uris)
 {
-  GKeyFile* key_file;
-  const char* desktop_file;
-  GError* error = NULL;
-  std::list<char*> results;
-
-  desktop_file = DesktopFile();
-
-  if (!desktop_file || strlen(desktop_file) <= 1)
-    return results;
-
-  key_file = g_key_file_new();
-  g_key_file_load_from_file(key_file, desktop_file, (GKeyFileFlags) 0, &error);
-
-  if (error)
-  {
-    g_error_free(error);
-    g_key_file_free(key_file);
-    return results;
-  }
-
-  char** mimes = g_key_file_get_string_list(key_file, "Desktop Entry", "MimeType", NULL, NULL);
-  if (!mimes)
-  {
-    g_key_file_free(key_file);
-    return results;
-  }
-
-  std::list<char*>::iterator it;
-  for (it = uris.begin(); it != uris.end(); it++)
-  {
-    GFile* file = g_file_new_for_uri(*it);
-    GFileInfo* info = g_file_query_info(file, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, G_FILE_QUERY_INFO_NONE, NULL, NULL);
-    const char* content_type = g_file_info_get_content_type(info);
-
-    int i = 0;
-    for (; mimes[i]; i++)
-    {
-      char* super_type = g_content_type_from_mime_type(mimes[i]);
-      if (g_content_type_is_a(content_type, super_type))
+  std::set<std::string> result;
+  
+  for (auto i : uris.Types())
+    for (auto j : GetSupportedTypes())
+      if (g_content_type_is_a(i.c_str(), j.c_str()))
       {
-        results.push_back(*it);
+        for (auto k : uris.UrisByType(i))
+          result.insert(k);
+          
         break;
       }
-      g_free(super_type);
-    }
-
-
-    g_object_unref(file);
-    g_object_unref(info);
-  }
-
-  g_strfreev(mimes);
-  g_key_file_free(key_file);
-  return results;
+    
+  return result;
 }
 
 gboolean BamfLauncherIcon::OnDndHoveredTimeout(gpointer data)
@@ -1121,14 +1089,14 @@ void BamfLauncherIcon::OnDndLeave()
   _dnd_hover_timer = 0;
 }
 
-nux::DndAction BamfLauncherIcon::OnQueryAcceptDrop(std::list<char*> uris)
+nux::DndAction BamfLauncherIcon::OnQueryAcceptDrop(unity::DndData& dnd_data)
 {
-  return ValidateUrisForLaunch(uris).empty() ? nux::DNDACTION_NONE : nux::DNDACTION_COPY;
+  return ValidateUrisForLaunch(dnd_data).empty() ? nux::DNDACTION_NONE : nux::DNDACTION_COPY;
 }
 
-void  BamfLauncherIcon::OnAcceptDrop(std::list<char*> uris)
+void  BamfLauncherIcon::OnAcceptDrop(unity::DndData& dnd_data)
 {
-  OpenInstanceWithUris(ValidateUrisForLaunch(uris));
+  OpenInstanceWithUris(ValidateUrisForLaunch(dnd_data));
 }
 
 void BamfLauncherIcon::OnDesktopFileChanged(GFileMonitor*        monitor,
@@ -1181,3 +1149,65 @@ BamfLauncherIcon::SwitcherPriority()
   g_list_free(children);
   return result;
 }
+
+const std::set<std::string>&
+BamfLauncherIcon::GetSupportedTypes()
+{
+  if (!_supported_types_filled)
+    FillSupportedTypes(this);
+    
+  return _supported_types;
+}
+
+gboolean
+BamfLauncherIcon::FillSupportedTypes(gpointer data)
+{
+  BamfLauncherIcon* self = (BamfLauncherIcon*) data;
+  
+  if (self->_fill_supported_types_id)
+  {
+    g_source_remove(self->_fill_supported_types_id);
+    self->_fill_supported_types_id = 0;
+  }
+  
+  if (!self->_supported_types_filled)
+  {
+    self->_supported_types_filled = true;
+    
+    self->_supported_types.clear();
+    
+    const char* desktop_file = self->DesktopFile();
+
+    if (!desktop_file || strlen(desktop_file) <= 1)
+      return false;
+      
+    GKeyFile* key_file = g_key_file_new();
+    unity::glib::Error error;
+
+    g_key_file_load_from_file(key_file, desktop_file, (GKeyFileFlags) 0, &error);
+
+    if (error)
+    {
+      g_key_file_free(key_file);
+      return false;
+    }
+    
+    char** mimes = g_key_file_get_string_list(key_file, "Desktop Entry", "MimeType", NULL, NULL);
+    if (!mimes)
+    {
+      g_key_file_free(key_file);
+      return false;
+    }
+    
+    for (int i=0; mimes[i]; i++)
+    {
+      unity::glib::String super_type(g_content_type_from_mime_type(mimes[i]));
+      self->_supported_types.insert(super_type.Str());
+    }
+    
+    g_key_file_free(key_file);
+    g_strfreev(mimes);
+  }
+
+  return false;
+}
--- unity-4.8.2.orig/plugins/unityshell/src/unityshell.cpp
+++ unity-4.8.2/plugins/unityshell/src/unityshell.cpp
@@ -112,6 +112,7 @@ UnityScreen::UnityScreen(CompScreen* scr
   , _last_output(nullptr)
   , switcher_desktop_icon(nullptr)
   , mActiveFbo (0)
+  , grab_index_ (0)
 {
   Timer timer;
   configure_logging();
@@ -190,23 +191,18 @@ UnityScreen::UnityScreen(CompScreen* scr
   optionSetAltTabTimeoutNotify(boost::bind(&UnityScreen::optionChanged, this, _1, _2));
   
   optionSetAltTabForwardInitiate(boost::bind(&UnityScreen::altTabForwardInitiate, this, _1, _2, _3));
-  optionSetAltTabForwardTerminate(boost::bind(&UnityScreen::altTabForwardTerminate, this, _1, _2, _3));
-  
+  optionSetAltTabForwardTerminate(boost::bind(&UnityScreen::altTabTerminateCommon, this, _1, _2, _3));
   optionSetAltTabPrevInitiate(boost::bind(&UnityScreen::altTabPrevInitiate, this, _1, _2, _3));
-  optionSetAltTabPrevTerminate(boost::bind(&UnityScreen::altTabPrevTerminate, this, _1, _2, _3));
   
   optionSetAltTabDetailStartInitiate(boost::bind(&UnityScreen::altTabDetailStartInitiate, this, _1, _2, _3));
-  optionSetAltTabDetailStartTerminate(boost::bind(&UnityScreen::altTabDetailStartTerminate, this, _1, _2, _3));
-
   optionSetAltTabDetailStopInitiate(boost::bind(&UnityScreen::altTabDetailStopInitiate, this, _1, _2, _3));
-  optionSetAltTabDetailStopTerminate(boost::bind(&UnityScreen::altTabDetailStopTerminate, this, _1, _2, _3));
-
   optionSetAltTabNextWindowInitiate(boost::bind(&UnityScreen::altTabNextWindowInitiate, this, _1, _2, _3));
-  optionSetAltTabNextWindowTerminate(boost::bind(&UnityScreen::altTabNextWindowTerminate, this, _1, _2, _3));
-
+/*
   optionSetAltTabExitInitiate(boost::bind(&UnityScreen::altTabExitInitiate, this, _1, _2, _3));
   optionSetAltTabExitTerminate(boost::bind(&UnityScreen::altTabExitTerminate, this, _1, _2, _3));
-  
+*/
+  optionSetAltTabLeftInitiate (boost::bind (&UnityScreen::altTabPrevInitiate, this, _1, _2, _3));
+  optionSetAltTabRightInitiate (boost::bind (&UnityScreen::altTabForwardInitiate, this, _1, _2, _3));
 
   for (unsigned int i = 0; i < G_N_ELEMENTS(_ubus_handles); i++)
     _ubus_handles[i] = 0;
@@ -619,7 +615,9 @@ void UnityScreen::handleEvent(XEvent* ev
   if (!skip_other_plugins)
     screen->handleEvent(event);
 
-  if (!skip_other_plugins && screen->otherGrabExist("deco", "move", "switcher", "resize", NULL))
+  if (!skip_other_plugins && 
+       screen->otherGrabExist("deco", "move", "switcher", "resize", NULL) && 
+      !switcherController->Visible())
   {
     wt->ProcessForeignEvent(event, NULL);
   }
@@ -802,63 +800,87 @@ bool UnityScreen::setKeyboardFocusKeyIni
   return false;
 }
 
-bool UnityScreen::altTabForwardInitiate(CompAction* action,
-                                        CompAction::State state,
-                                        CompOption::Vector& options)
+bool UnityScreen::altTabInitiateCommon(CompAction *action,
+				       CompAction::State state,
+				       CompOption::Vector& options)
 {
-  if (switcherController->Visible())
+  std::vector<AbstractLauncherIcon*> results;
+
+  if (!switcher_desktop_icon)
   {
-    switcherController->Next();
+    switcher_desktop_icon = new DesktopLauncherIcon(launcher);
+    switcher_desktop_icon->SinkReference();
   }
-  else
-  {
-    std::vector<AbstractLauncherIcon*> results;
 
-    if (!switcher_desktop_icon)
-    {
-      switcher_desktop_icon = new DesktopLauncherIcon(launcher);
-      switcher_desktop_icon->SinkReference();
-    }
+  results.push_back(switcher_desktop_icon);
 
-    results.push_back(switcher_desktop_icon);
+  LauncherModel::iterator it;
+  for (it = launcher->GetModel()->begin(); it != launcher->GetModel()->end(); it++)
+    if ((*it)->ShowInSwitcher())
+      results.push_back(*it);
 
-    LauncherModel::iterator it;
-    for (it = launcher->GetModel()->begin(); it != launcher->GetModel()->end(); it++)
-      if ((*it)->ShowInSwitcher())
-        results.push_back(*it);
-
-    // maybe check launcher position/hide state?
-    switcherController->SetWorkspace(nux::Geometry(_primary_monitor.x + 100,
-                                                   _primary_monitor.y + 100,
-                                                   _primary_monitor.width - 200,
-                                                   _primary_monitor.height - 200));
-    switcherController->Show(SwitcherController::ALL, SwitcherController::FOCUS_ORDER, false, results);
-  }
+  screen->addAction (&optionGetAltTabRight ());
+  screen->addAction (&optionGetAltTabDetailStart ());
+  screen->addAction (&optionGetAltTabDetailStop ());
+  screen->addAction (&optionGetAltTabLeft ());
+  screen->addAction (&optionGetAltTabNextWindow ());
 
-  action->setState(action->state() | CompAction::StateTermKey);
-  return false;
+  if (!grab_index_)
+    grab_index_ = screen->pushGrab (screen->invisibleCursor(), "unity-switcher");
+
+  // maybe check launcher position/hide state?
+  switcherController->SetWorkspace(nux::Geometry(_primary_monitor.x + 100,
+						 _primary_monitor.y + 100,
+						 _primary_monitor.width - 200,
+						 _primary_monitor.height - 200));
+  switcherController->Show(SwitcherController::ALL, SwitcherController::FOCUS_ORDER, false, results);
+  return true;
 }
 
-bool UnityScreen::altTabForwardTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options)
+bool UnityScreen::altTabTerminateCommon(CompAction* action,
+					CompAction::State state,
+					CompOption::Vector& options)
 {
-  action->setState(action->state() & (unsigned)~(CompAction::StateTermKey));
-  bool accept_state = (state & CompAction::StateCancel) == 0;
-  switcherController->Hide(accept_state);
-  return false;
+  if (grab_index_)
+  {
+    // remove grab before calling hide so workspace switcher doesn't fail
+    screen->removeGrab(grab_index_, NULL);
+    grab_index_ = 0;
+
+    screen->removeAction (&optionGetAltTabRight ());
+    screen->removeAction (&optionGetAltTabDetailStart ());
+    screen->removeAction (&optionGetAltTabDetailStop ());
+    screen->removeAction (&optionGetAltTabLeft ());
+    screen->removeAction (&optionGetAltTabNextWindow ());
+    
+    bool accept_state = (state & CompAction::StateCancel) == 0;
+    switcherController->Hide(accept_state);
+  }
+
+  action->setState (action->state() & (unsigned)~(CompAction::StateTermKey));
+  return true;
 }
 
-bool UnityScreen::altTabPrevInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options)
+bool UnityScreen::altTabForwardInitiate(CompAction* action,
+                                        CompAction::State state,
+                                        CompOption::Vector& options)
 {
   if (switcherController->Visible())
-    switcherController->Prev();
+
+    switcherController->Next();
+  else
+    altTabInitiateCommon(action, state, options);
 
   action->setState(action->state() | CompAction::StateTermKey);
   return false;
 }
 
-bool UnityScreen::altTabPrevTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options)
+
+bool UnityScreen::altTabPrevInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options)
 {
-  action->setState(action->state() & (unsigned)~(CompAction::StateTermKey));
+  if (switcherController->Visible())
+    switcherController->Prev();
+
   return false;
 }
 
@@ -867,13 +889,6 @@ bool UnityScreen::altTabDetailStartIniti
   if (switcherController->Visible())
     switcherController->SetDetail(true);
 
-  action->setState(action->state() | CompAction::StateTermKey);
-  return false;
-}
-
-bool UnityScreen::altTabDetailStartTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options)
-{
-  action->setState(action->state() & (unsigned)~(CompAction::StateTermKey));
   return false;
 }
 
@@ -882,13 +897,6 @@ bool UnityScreen::altTabDetailStopInitia
   if (switcherController->Visible())
     switcherController->SetDetail(false);
 
-  action->setState(action->state() | CompAction::StateTermKey);
-  return false;
-}
-
-bool UnityScreen::altTabDetailStopTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options)
-{
-  action->setState(action->state() & (unsigned)~(CompAction::StateTermKey));
   return false;
 }
 
@@ -897,26 +905,6 @@ bool UnityScreen::altTabNextWindowInitia
   if (switcherController->Visible())
     switcherController->NextDetail();
 
-  action->setState(action->state() | CompAction::StateTermKey);
-  return false;
-}
-
-bool UnityScreen::altTabNextWindowTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options)
-{
-  action->setState(action->state() & (unsigned)~(CompAction::StateTermKey));
-  return false;
-}
-
-bool UnityScreen::altTabExitInitiate(CompAction* action, CompAction::State state, CompOption::Vector& options)
-{
-  switcherController->Hide(false);
-  action->setState(action->state() | CompAction::StateTermKey);
-  return false;
-}
-
-bool UnityScreen::altTabExitTerminate(CompAction* action, CompAction::State state, CompOption::Vector& options)
-{
-  action->setState(action->state() & (unsigned)~(CompAction::StateTermKey));
   return false;
 }
 
--- unity-4.8.2.orig/plugins/unityshell/src/Launcher.h
+++ unity-4.8.2/plugins/unityshell/src/Launcher.h
@@ -27,6 +27,10 @@
 #include <Nux/View.h>
 #include <Nux/BaseWindow.h>
 
+#include "AbstractIconRenderer.h"
+#include "DNDCollectionWindow.h"
+#include "DndData.h"
+#include "GeisAdapter.h"
 #include "Introspectable.h"
 #include "LauncherIcon.h"
 #include "LauncherDragWindow.h"
@@ -35,9 +39,6 @@
 #include "NuxGraphics/IOpenGLAsmShader.h"
 #include "Nux/TimerProc.h"
 #include "PluginAdapter.h"
-#include "GeisAdapter.h"
-
-#include "AbstractIconRenderer.h"
 
 #define ANIM_DURATION_SHORT 125
 #define ANIM_DURATION       200
@@ -204,6 +205,7 @@ protected:
   const gchar* GetName();
   void AddProperties(GVariantBuilder* builder);
 
+  void DndLeave();
   void ProcessDndEnter();
   void ProcessDndLeave();
   void ProcessDndMove(int x, int y, std::list<char*> mimes);
@@ -361,9 +363,9 @@ private:
 
   gboolean TapOnSuper();
 
-  std::list<char*> StringToUriList(char* input);
-
   static void SettingsChanged(GSettings* settings, gchar* key, Launcher* self);
+  
+  void OnDNDDataCollected(const std::list<char*>& mimes);
 
   nux::HLayout* m_Layout;
   int m_ContentOffsetY;
@@ -446,12 +448,14 @@ private:
   LauncherHoverMachine* _hover_machine;
   CompScreen* _screen;
 
-  std::list<char*> _drag_data;
+  unity::DndData _dnd_data;
   nux::DndAction    _drag_action;
   bool              _data_checked;
   bool              _steal_drag;
   bool              _drag_edge_touching;
   LauncherIcon*     _dnd_hovered_icon;
+  unity::DNDCollectionWindow* _collection_window;
+  sigc::connection _on_data_collected_connection;
 
   Atom              _selection_atom;
 
@@ -489,5 +493,3 @@ private:
 };
 
 #endif // LAUNCHER_H
-
-
--- unity-4.8.2.orig/plugins/unityshell/src/TrashLauncherIcon.h
+++ unity-4.8.2/plugins/unityshell/src/TrashLauncherIcon.h
@@ -20,6 +20,7 @@
 #ifndef TRASHLAUNCHERICON_H
 #define TRASHLAUNCHERICON_H
 
+#include "DndData.h"
 #include "SimpleLauncherIcon.h"
 
 class TrashLauncherIcon : public SimpleLauncherIcon
@@ -35,8 +36,8 @@ public:
 protected:
   void UpdateTrashIcon();
 
-  nux::DndAction OnQueryAcceptDrop(std::list<char*> uris);
-  void OnAcceptDrop(std::list<char*> uris);
+  nux::DndAction OnQueryAcceptDrop(unity::DndData& dnd_data);
+  void OnAcceptDrop(unity::DndData& dnd_data);
 
 private:
   gulong _on_trash_changed_handler_id;
